<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>abc235_g Painting Weighted Graph | Algorithm Notes</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="A typical instance of tree DP of merge."><meta name=generator content="Hugo 0.114.1"><meta name=robots content="noindex, nofollow"><link rel=stylesheet href=/ananke/css/main.min.css><link rel=stylesheet href=/css/custom.css><link rel="shortcut icon" href=/favicon/android-chrome-192x192.png type=image/x-icon><meta property="og:title" content="abc235_g Painting Weighted Graph"><meta property="og:description" content="A typical instance of tree DP of merge."><meta property="og:type" content="article"><meta property="og:url" content="/upsolve/abc235_g_painting_weighted_graph/"><meta property="article:section" content="upsolve"><meta property="article:published_time" content="2022-01-18T15:15:18+08:00"><meta property="article:modified_time" content="2022-01-18T15:15:18+08:00"><meta itemprop=name content="abc235_g Painting Weighted Graph"><meta itemprop=description content="A typical instance of tree DP of merge."><meta itemprop=datePublished content="2022-01-18T15:15:18+08:00"><meta itemprop=dateModified content="2022-01-18T15:15:18+08:00"><meta itemprop=wordCount content="509"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="abc235_g Painting Weighted Graph"><meta name=twitter:description content="A typical instance of tree DP of merge."><script>MathJax={loader:{load:["[tex]/physics"]},tex:{inlineMath:[["$","$"],["\\(","\\)"]],packages:{"[+]":["xypic","physics"]},macros:{RR:"{\\bf R}",bm:["{\\bf #1}",1],floor:[`\\left \\lfloor #1 \\right \\rfloor`,1],ceil:[`\\left \\lceil #1 \\right \\rceil`,1],dif:"\\mathop{}\\!\\mathrm{d}",mathlarger:["{\\large #1}",1],dsone:"\\unicode{x1D7D9}",sub:"\\subset",sube:"\\subseteq",subne:"\\subsetneq",sse:"\\subseteq",spe:"\\supseteq",qed:"\\tag*{$\\blacksquare$}",xor:"\\oplus",Z:"\\mathbb{Z}",N:"\\mathbb{N}",F:"\\mathbb{F}",tran:"^{\\mkern-1.5mu\\mathsf{T}}",lcm:["\\operatorname{lcm}"],lpd:["\\operatorname{lpd}"],lpf:["\\operatorname{lpf}"],rank:["\\operatorname{rank}"],init:["\\operatorname{init}"],ter:["\\operatorname{ter}"],nil:"\\emptyset",iso:"\\simeq",Bar:"\\overline",ffact:["{#1}^{\\underline{#2}}",2],R:"\\mathbb{R}",O:"\\emptyset",xto:["\\xrightarrow{#1}",1],xor:"\\oplus"},tags:"ams"},chtml:{mtextInheritFont:!0}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js></script><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/styles/default.min.css><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/highlight.min.js></script>
<script>hljs.highlightAll()</script></head><body class="ma0 avenir bg-near-white"><header><div class=bg-black><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=/ class="f3 fw2 hover-white no-underline white-90 dib">Algorithm Notes</a><div class="flex-l items-center"><ul class="pl0 mr3"><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/cpp/ title="C++ page">C++</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/gt/ title="Graph Theory page">Graph Theory</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/la/ title="Linear Algebra page">Linear Algebra</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/posts/ title="Posts page">Posts</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/tutorials/ title="Tutorials page">Tutorials</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/upsolve/ title="Upsolve page">Upsolve</a></li></ul><div class=ananke-socials></div></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l flex-wrap justify-between mw8 center ph3"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked">UPSOLVES</aside><div id=sharing class="mt3 ananke-socials"></div><h1 class="f1 athelas mt3 mb1">abc235_g Painting Weighted Graph</h1><time class="f6 mv4 dib tracked" datetime=2022-01-18T15:15:18+08:00>January 18, 2022</time></header><div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>For a graph <span class="math inline">\(G\)</span>, we group all
subsets of <span class="math inline">\(V(G)\)</span> that can be painted
with no more than <span class="math inline">\(K\)</span> operations by
the least number of operations required to paint a subset. There are no
more than <span class="math inline">\(K + 1\)</span> groups of subsets
of <span class="math inline">\(V(G)\)</span>. For a subset <span class="math inline">\(U\)</span> of <span class="math inline">\(V(G)\)</span>, let <span class="math inline">\(\delta_G(U)\)</span> denote the least number of
operations required to paint <span class="math inline">\(U\)</span> in
graph <span class="math inline">\(G\)</span>.</p><p>Let <span class="math inline">\(C_1\)</span>, <span class="math inline">\(C_2\)</span> be connected subgraphs of <span class="math inline">\(G\)</span> that satisfy the following
conditions</p><ul><li><span class="math inline">\(C_1\)</span> and <span class="math inline">\(C_2\)</span> are independent, that is, <span class="math inline">\(V(C_1) \cap V(C_2) = \O\)</span>.</li><li>There is an edge <span class="math inline">\(e\)</span> in <span class="math inline">\(G\)</span> connecting <span class="math inline">\(C_1\)</span> and <span class="math inline">\(C_2\)</span>, and <span class="math inline">\(e\)</span> has a greater weight than any edge in
<span class="math inline">\(C_1\)</span> or <span class="math inline">\(C_2\)</span>.</li></ul><p>Let <span class="math inline">\(C'\)</span> denote the graph
<span class="math inline">\(C_1 \cup C_2\)</span>ï¼Œlet <span class="math inline">\(C\)</span> denote the graph <span class="math inline">\(C_1 \cup C_2 \cup e\)</span>. Note that <span class="math inline">\(V(C) = V(C') = V(C_1) \cup
V(C_2)\)</span>.</p><p>It is obvious that <span class="math inline">\(p(C') = p(C_1)
p(C_2)\)</span>. Moreover, we have <span class="math inline">\(p(C) =
p(C') - x^2 + x\)</span>. (why?)</p><p>The following facts holds</p><ul><li>For a subset <span class="math inline">\(U\)</span> of <span class="math inline">\(V(C)\)</span>, if <span class="math inline">\(U
\ne V(C)\)</span>, then <span class="math inline">\(\delta_C(U) =
\delta_{C'}(U)\)</span>.</li><li><span class="math inline">\(\delta_C(V(C)) = 1\)</span>.</li><li><span class="math inline">\(\delta_{C'}(V(C)) = 2\)</span>.</li></ul><h1 id=analysis-of-time-complexity>Analysis of time complexity</h1><p>Consider connecting two connected components <span class="math inline">\(C_1\)</span> and <span class="math inline">\(C_2\)</span>, depending on whether their number of
vertices are less than <span class="math inline">\(K\)</span> or
not:</p><ul><li>If both of them has <span class="math inline">\(K\)</span> or more
vertices. Such merge will occur no more than <span class="math inline">\(N/K\)</span> times, and each of them can be
computed in $O(K^2) $ time, so it costs a total of <span class="math inline">\(O(NK)\)</span> time.</li><li>If both of them has less than <span class="math inline">\(K\)</span>
vertices. Suppose that all cost required so far is considered when the
size of connected component exceeds <span class="math inline">\(K\)</span> for the first time. The time complexity
of the process of connection is <span class="math inline">\(O(K^2)\)</span>, resulting in <span class="math inline">\(O(N/K)\)</span> number of connected components
with size <span class="math inline">\(\ge K\)</span>, so it will cost a
total of <span class="math inline">\(O(NK)\)</span> time.</li><li>If one has <span class="math inline">\(K\)</span> or more vertices
while the other has less than <span class="math inline">\(K\)</span>.
Assume <span class="math inline">\(|C_1| &lt; K\)</span>, such a
connection costs <span class="math inline">\(O(|C_1|K)\)</span> time,
and occurs at most once for a connected component with size less than
<span class="math inline">\(K\)</span> (and each vertex appears at most
once in the smaller part of such merges). So it costs a total of <span class="math inline">\(O(NK)\)</span> time.</li></ul><p>Therefore, the overall time complexity is <span class="math inline">\(O(NK)\)</span>.</p><h1 id=code>Code</h1><pre class=cpp><code>#include &lt;utils.hpp&gt;
#include &lt;dsu.hpp&gt;
#include &lt;m3.hpp&gt;
#include &lt;poly.hpp&gt;

void solve() {
  INT(N, M, K);
  UnionFind dsu(N + 1);
  using poly = Poly&lt;mint&gt;;
  map&lt;int, vii&gt; e;
  rep (M) {
    INT(a, b, c);
    e[c].pb(a, b);
  }
  vector&lt;poly&gt; p(N + 1, {1, 1});
  FOR (c, ab, e) {
    vi old_roots;
    FOR (a, b, ab) {
      if (not dsu.same(a, b)) {
        old_roots.pb(dsu.root(b));
        dsu.unite(a, b);
      }
    }
    map&lt;int, int&gt; cnt;
    FOR (u, old_roots) {
      int r = dsu.root(u);
      cnt[r]++;
      p[r] *= p[u];
      if (SZ(p[r]) &gt; K + 1)
        p[r].resize(K + 1);
    }

    FOR (root, C, cnt) {
      p[root][1] += 1;
      if (C + 1 &lt;= K) {
        p[root][C + 1] -= 1;
      }
    }
  }

  poly prod = {1};
  up (i, 1, N)
    if (dsu.is_root(i)) {
      prod *= p[i];
      if (SZ(prod) &gt; K + 1)
        prod.resize(K + 1);
    }
  pl(acc&lt;mint&gt;(prod));
}</code></pre><ul class=pa0></ul><div class="mt6 instapaper_ignoref"></div></div><aside class="w-30-l mt6-l"></aside></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href>&copy; Algorithm Notes 2023</a><div><div class=ananke-socials></div></div></div></footer></body></html>